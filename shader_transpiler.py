import os

class ShaderTranspiler:

	shaderHeader = """// This file was automatically generated by shader_transpiler.py
// You should never edit this file directly.

#pragma once

#include <string>

namespace playground
{

class %sShader
{

public:
	static const std::string vertSource;
	static const std::string fragSource;
	
};

} // namespace playground
"""

	shaderSource = """// This file was automatically generated by shader_transpiler.py
// You should never edit this file directly.

#include "shaders/%s_shader.h"

namespace playground
{

const std::string %sShader::vertSource = R"(
%s
)";

const std::string %sShader::fragSource = R"(
%s
)";

} // namespace playground
"""

	def __init__(self):
		pass
		
	def transpileDir(self, dir):
		for root, dirs, files in os.walk(dir):
			for file in files:
				self.transpile(os.path.join(root, file))
	
	def transpile(self, src):
		filePath, asd = os.path.splitext(src)
		fileName, fileExtension = os.path.splitext(os.path.basename(src))

		# Only process valid shader files.
		# We pair shaders based on their vertex shader.
		if fileExtension != '.vert':
			return

		print("Transpiling Shader: %s" % filePath)

		# Open the vertex shader.
		with open(src, 'r') as vertex:
			vertData = vertex.read()

		# Make sure an accompanying frag shader exists.
		if not os.path.isfile(filePath + '.frag'):
			print("Shader Warning: No accompanying frag shader could be found for '%s'" % filePath)
			return

		# Open the accompanying fragment shader.
		with open(filePath + '.frag', 'r') as fragment:
			fragData = fragment.read()

		# Write our header file.
		with open(filePath + '_shader.h', 'w+') as header:
			header.write(self.shaderHeader % 
				(fileName))

		# Write our source file.
		with open(filePath + '_shader.cpp', 'w+') as source:
			source.write(self.shaderSource %
				(fileName, fileName, vertData, fileName, fragData))
